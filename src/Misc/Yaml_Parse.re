open IO.Infix;

module Parser = {
  [@bs.module "yaml"] external parse: string => Js.Json.t = "parse";
};

type t = {
  advantages: list(Js.Json.t),
  animistForces: list(Js.Json.t),
  arcaneBardTraditions: list(Js.Json.t),
  arcaneDancerTraditions: list(Js.Json.t),
  armorTypes: list(Js.Json.t),
  aspects: list(Js.Json.t),
  attributes: list(Js.Json.t),
  blessedTraditions: list(Js.Json.t),
  blessings: list(Js.Json.t),
  brews: list(Js.Json.t),
  cantrips: list(Js.Json.t),
  combatSpecialAbilityGroups: list(Js.Json.t),
  combatTechniqueGroups: list(Js.Json.t),
  combatTechniques: list(Js.Json.t),
  conditions: list(Js.Json.t),
  cultures: list(Js.Json.t),
  curses: list(Js.Json.t),
  derivedCharacteristics: list(Js.Json.t),
  disadvantages: list(Js.Json.t),
  dominationRituals: list(Js.Json.t),
  elvenMagicalSongs: list(Js.Json.t),
  items: list(Js.Json.t),
  equipmentGroups: list(Js.Json.t),
  equipmentPackages: list(Js.Json.t),
  experienceLevels: list(Js.Json.t),
  eyeColors: list(Js.Json.t),
  focusRules: list(Js.Json.t),
  geodeRituals: list(Js.Json.t),
  hairColors: list(Js.Json.t),
  liturgicalChantGroups: list(Js.Json.t),
  liturgicalChants: list(Js.Json.t),
  magicalDances: list(Js.Json.t),
  magicalMelodies: list(Js.Json.t),
  magicalTraditions: list(Js.Json.t),
  optionalRules: list(Js.Json.t),
  pacts: list(Js.Json.t),
  professions: list(Js.Json.t),
  properties: list(Js.Json.t),
  publications: list(Js.Json.t),
  races: list(Js.Json.t),
  reaches: list(Js.Json.t),
  rogueSpells: list(Js.Json.t),
  skillGroups: list(Js.Json.t),
  skills: list(Js.Json.t),
  socialStatuses: list(Js.Json.t),
  specialAbilities: list(Js.Json.t),
  specialAbilityGroups: list(Js.Json.t),
  spellGroups: list(Js.Json.t),
  spells: list(Js.Json.t),
  states: list(Js.Json.t),
  subjects: list(Js.Json.t),
  tribes: list(Js.Json.t),
  zibiljaRituals: list(Js.Json.t),
};

let parseUI = locale =>
  Node.Path.join([|".", "src", "Database", "UI", locale ++ ".yml"|])
  |> IO.readFile
  <&> Parser.parse;

let parseFilesOfEntryType = dir =>
  Node.Path.join([|".", "src", "Database", dir|])
  |> Directory.getDirectoryContents
  |> IO.mapM(x => x |> IO.readFile <&> Parser.parse);

let parseDirectories = (~onProgress, dirs) => {
  let max = dirs |> Ley_List.length |> Js.Int.toFloat;

  dirs
  |> IO.imapM((i, dir) =>
       dir
       |> parseFilesOfEntryType
       <&> (
         res => {
           onProgress((Js.Int.toFloat(i) +. 1.) /. max);
           res;
         }
       )
     );
};

let dirs = [
  "Advantages",
  "AnimistForces",
  "ArcaneBardTraditions",
  "ArcaneDancerTraditions",
  "ArmorTypes",
  "Aspects",
  "Attributes",
  "BlessedTraditions",
  "Blessings",
  "Brews",
  "Cantrips",
  "CombatSpecialAbilityGroups",
  "CombatTechniqueGroups",
  "CombatTechniques",
  "Conditions",
  "Cultures",
  "Curses",
  "DerivedCharacteristics",
  "Disadvantages",
  "DominationRituals",
  "ElvenMagicalSongs",
  "Items",
  "EquipmentGroups",
  "EquipmentPackages",
  "ExperienceLevels",
  "EyeColors",
  "FocusRules",
  "GeodeRituals",
  "HairColors",
  "LiturgicalChantGroups",
  "LiturgicalChants",
  "MagicalDances",
  "MagicalMelodies",
  "MagicalTraditions",
  "OptionalRules",
  "Pacts",
  "Professions",
  "Properties",
  "Publications",
  "Races",
  "Reaches",
  "RogueSpells",
  "SkillGroups",
  "Skills",
  "SocialStatuses",
  "SpecialAbilities",
  "SpecialAbilityGroups",
  "SpellGroups",
  "Spells",
  "States",
  "Subjects",
  "Tribes",
  "ZibiljaRituals",
];

let parseFiles = (~onProgress) =>
  dirs
  |> parseDirectories(~onProgress)
  <&> (
    fun
    | [
        advantages,
        animistForces,
        arcaneBardTraditions,
        arcaneDancerTraditions,
        armorTypes,
        aspects,
        attributes,
        blessedTraditions,
        blessings,
        brews,
        cantrips,
        combatSpecialAbilityGroups,
        combatTechniqueGroups,
        combatTechniques,
        conditions,
        cultures,
        curses,
        derivedCharacteristics,
        disadvantages,
        dominationRituals,
        elvenMagicalSongs,
        items,
        equipmentGroups,
        equipmentPackages,
        experienceLevels,
        eyeColors,
        focusRules,
        geodeRituals,
        hairColors,
        liturgicalChantGroups,
        liturgicalChants,
        magicalDances,
        magicalMelodies,
        magicalTraditions,
        optionalRules,
        pacts,
        professions,
        properties,
        publications,
        races,
        reaches,
        rogueSpells,
        skillGroups,
        skills,
        socialStatuses,
        specialAbilities,
        specialAbilityGroups,
        spellGroups,
        spells,
        states,
        subjects,
        tribes,
        zibiljaRituals,
      ] => {
        advantages,
        animistForces,
        arcaneBardTraditions,
        arcaneDancerTraditions,
        armorTypes,
        aspects,
        attributes,
        blessedTraditions,
        blessings,
        brews,
        cantrips,
        combatSpecialAbilityGroups,
        combatTechniqueGroups,
        combatTechniques,
        conditions,
        cultures,
        curses,
        derivedCharacteristics,
        disadvantages,
        dominationRituals,
        elvenMagicalSongs,
        items,
        equipmentGroups,
        equipmentPackages,
        experienceLevels,
        eyeColors,
        focusRules,
        geodeRituals,
        hairColors,
        liturgicalChantGroups,
        liturgicalChants,
        magicalDances,
        magicalMelodies,
        magicalTraditions,
        optionalRules,
        pacts,
        professions,
        properties,
        publications,
        races,
        reaches,
        rogueSpells,
        skillGroups,
        skills,
        socialStatuses,
        specialAbilities,
        specialAbilityGroups,
        spellGroups,
        spells,
        states,
        subjects,
        tribes,
        zibiljaRituals,
      }
    | xs =>
      failwith(
        "Unexpected length of directories: "
        ++ Ley_Int.show(Ley_List.length(xs)),
      )
  );
