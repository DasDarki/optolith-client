// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE

import * as List from "bs-platform/lib/es6/list.js";
import * as $$Array from "bs-platform/lib/es6/array.js";
import * as Curry from "bs-platform/lib/es6/curry.js";
import * as Js_int from "bs-platform/lib/es6/js_int.js";
import * as $$String from "bs-platform/lib/es6/string.js";
import * as Caml_obj from "bs-platform/lib/es6/caml_obj.js";
import * as Caml_int32 from "bs-platform/lib/es6/caml_int32.js";
import * as Pervasives from "bs-platform/lib/es6/pervasives.js";
import * as Caml_option from "bs-platform/lib/es6/caml_option.js";
import * as Ley_Int$OptolithClient from "./Ley_Int.bs.js";
import * as Ley_Ord$OptolithClient from "./Ley_Ord.bs.js";
import * as Ley_Tuple$OptolithClient from "./Ley_Tuple.bs.js";
import * as Ley_Option$OptolithClient from "./Ley_Option.bs.js";
import * as Ley_Function$OptolithClient from "./Ley_Function.bs.js";

function $less$$great(f, xs) {
  if (xs) {
    return /* :: */[
            Curry._1(f, xs[0]),
            $less$$great(f, xs[1])
          ];
  } else {
    return /* [] */0;
  }
}

function $less$amp$great(xs, f) {
  return $less$$great(f, xs);
}

var Functor = {
  $less$$great: $less$$great,
  fmap: $less$$great,
  $less$amp$great: $less$amp$great,
  fmapF: $less$amp$great
};

function $less$star$great(fs, xs) {
  if (!fs) {
    return /* [] */0;
  }
  if (!xs) {
    return /* [] */0;
  }
  var x = xs[0];
  return Pervasives.$at($less$$great((function (f) {
                    return Curry._1(f, x);
                  }), fs), $less$star$great(fs, xs[1]));
}

var Applicative = {
  $less$star$great: $less$star$great,
  ap: $less$star$great
};

function $less$pipe$great(xs, ys) {
  if (xs) {
    return xs;
  } else {
    return ys;
  }
}

function guard(pred) {
  if (pred) {
    return /* :: */[
            undefined,
            /* [] */0
          ];
  } else {
    return /* [] */0;
  }
}

var Alternative = {
  $less$pipe$great: $less$pipe$great,
  alt: $less$pipe$great,
  guard: guard
};

function $great$great$eq(xs, f) {
  if (xs) {
    return Pervasives.$at(Curry._1(f, xs[0]), $great$great$eq(xs[1], f));
  } else {
    return /* [] */0;
  }
}

function $eq$less$less(f, mx) {
  return $great$great$eq(mx, f);
}

function $great$great(x, y) {
  return $great$great$eq(x, (function (param) {
                return Ley_Function$OptolithClient.$$const(y, param);
              }));
}

function $great$eq$great(f, g, x) {
  return $great$great$eq(Curry._1(f, x), g);
}

function join(x) {
  return $great$great$eq(x, Ley_Function$OptolithClient.id);
}

function liftM2(f, mx, my) {
  return $great$great$eq(mx, (function (x) {
                return $less$$great(Curry._1(f, x), my);
              }));
}

function liftM3(f, mx, my, mz) {
  return $great$great$eq(mx, (function (x) {
                return $great$great$eq(my, (function (y) {
                              return $less$$great(Curry._2(f, x, y), mz);
                            }));
              }));
}

function liftM4(f, mx, my, mz, ma) {
  return $great$great$eq(mx, (function (x) {
                return $great$great$eq(my, (function (y) {
                              return $great$great$eq(mz, (function (z) {
                                            return $less$$great(Curry._3(f, x, y, z), ma);
                                          }));
                            }));
              }));
}

var Monad = {
  $great$great$eq: $great$great$eq,
  bind: $great$great$eq,
  $eq$less$less: $eq$less$less,
  bindF: $eq$less$less,
  $great$great: $great$great,
  then_: $great$great,
  $great$eq$great: $great$eq$great,
  kleisli: $great$eq$great,
  join: join,
  liftM2: liftM2,
  liftM3: liftM3,
  liftM4: liftM4
};

function foldr(f, initial, xs) {
  if (xs) {
    return Curry._2(f, xs[0], foldr(f, initial, xs[1]));
  } else {
    return initial;
  }
}

function foldr1(f, xs) {
  if (xs) {
    return foldr(f, xs[0], xs[1]);
  } else {
    return Pervasives.invalid_arg("Cannot apply foldr1 to an empty list.");
  }
}

function foldl(f, _initial, _xs) {
  while(true) {
    var xs = _xs;
    var initial = _initial;
    if (!xs) {
      return initial;
    }
    _xs = xs[1];
    _initial = Curry._2(f, initial, xs[0]);
    continue ;
  };
}

function foldl1(f, xs) {
  if (xs) {
    return foldl(f, xs[0], xs[1]);
  } else {
    return Pervasives.invalid_arg("Cannot apply foldl1 to an empty list.");
  }
}

function toList(xs) {
  return xs;
}

function $$null(xs) {
  if (xs) {
    return false;
  } else {
    return true;
  }
}

var length = List.length;

function elem(e, xs) {
  return List.exists((function (x) {
                return Caml_obj.caml_equal(e, x);
              }), xs);
}

function sum(xs) {
  return foldr((function (prim, prim$1) {
                return prim + prim$1 | 0;
              }), 0, xs);
}

function product(xs) {
  return foldr(Caml_int32.imul, 1, xs);
}

function maximum(xs) {
  return foldr((function (prim, prim$1) {
                return Math.max(prim, prim$1);
              }), Js_int.min, xs);
}

function minimum(xs) {
  return foldr((function (prim, prim$1) {
                return Math.min(prim, prim$1);
              }), Js_int.max, xs);
}

function concat(xss) {
  return $great$great$eq(xss, Ley_Function$OptolithClient.id);
}

function concatMap(f, xs) {
  return $great$great$eq(xs, f);
}

function con(_xs) {
  while(true) {
    var xs = _xs;
    if (!xs) {
      return true;
    }
    if (!xs[0]) {
      return false;
    }
    _xs = xs[1];
    continue ;
  };
}

function dis(_xs) {
  while(true) {
    var xs = _xs;
    if (!xs) {
      return false;
    }
    if (xs[0]) {
      return true;
    }
    _xs = xs[1];
    continue ;
  };
}

function any(f, _xs) {
  while(true) {
    var xs = _xs;
    if (!xs) {
      return false;
    }
    if (Curry._1(f, xs[0])) {
      return true;
    }
    _xs = xs[1];
    continue ;
  };
}

function all(f, _xs) {
  while(true) {
    var xs = _xs;
    if (!xs) {
      return true;
    }
    if (!Curry._1(f, xs[0])) {
      return false;
    }
    _xs = xs[1];
    continue ;
  };
}

function notElem(e, xs) {
  return !elem(e, xs);
}

function find(f, _xs) {
  while(true) {
    var xs = _xs;
    if (!xs) {
      return ;
    }
    var y = xs[0];
    if (Curry._1(f, y)) {
      return Caml_option.some(y);
    }
    _xs = xs[1];
    continue ;
  };
}

var Foldable = {
  foldr: foldr,
  foldr1: foldr1,
  foldl: foldl,
  foldl1: foldl1,
  toList: toList,
  $$null: $$null,
  length: length,
  elem: elem,
  sum: sum,
  product: product,
  maximum: maximum,
  minimum: minimum,
  concat: concat,
  concatMap: concatMap,
  con: con,
  dis: dis,
  any: any,
  all: all,
  notElem: notElem,
  find: find
};

function indexedAux(i, xs) {
  if (xs) {
    return /* :: */[
            /* tuple */[
              i,
              xs[0]
            ],
            indexedAux(i + 1 | 0, xs[1])
          ];
  } else {
    return /* [] */0;
  }
}

function indexed(xs) {
  return indexedAux(0, xs);
}

function deleteAt(index, xs) {
  if (index < 0) {
    return xs;
  }
  if (!xs) {
    return /* [] */0;
  }
  var xs$1 = xs[1];
  if (index === 0) {
    return xs$1;
  } else {
    return /* :: */[
            xs[0],
            deleteAt(index - 1 | 0, xs$1)
          ];
  }
}

function deleteAtPair(index, xs) {
  if (index < 0) {
    return /* tuple */[
            undefined,
            xs
          ];
  }
  if (!xs) {
    return /* tuple */[
            undefined,
            /* [] */0
          ];
  }
  var xs$1 = xs[1];
  var x = xs[0];
  if (index === 0) {
    return /* tuple */[
            Caml_option.some(x),
            xs$1
          ];
  } else {
    return Ley_Tuple$OptolithClient.Bifunctor.second((function (xs) {
                  return /* :: */[
                          x,
                          xs
                        ];
                }), deleteAtPair(index - 1 | 0, xs$1));
  }
}

function setAt(index, e, xs) {
  if (index < 0) {
    return xs;
  }
  if (!xs) {
    return /* [] */0;
  }
  var xs$1 = xs[1];
  if (index === 0) {
    return /* :: */[
            e,
            xs$1
          ];
  } else {
    return /* :: */[
            xs[0],
            setAt(index - 1 | 0, e, xs$1)
          ];
  }
}

function modifyAt(index, f, xs) {
  if (index < 0) {
    return xs;
  }
  if (!xs) {
    return /* [] */0;
  }
  var xs$1 = xs[1];
  var x = xs[0];
  if (index === 0) {
    return /* :: */[
            Curry._1(f, x),
            xs$1
          ];
  } else {
    return /* :: */[
            x,
            modifyAt(index - 1 | 0, f, xs$1)
          ];
  }
}

function updateAt(index, f, xs) {
  if (index < 0) {
    return xs;
  }
  if (!xs) {
    return /* [] */0;
  }
  var xs$1 = xs[1];
  var x = xs[0];
  if (index === 0) {
    return Ley_Option$OptolithClient.option(xs$1, (function (x$prime) {
                  return /* :: */[
                          x$prime,
                          xs$1
                        ];
                }), Curry._1(f, x));
  } else {
    return /* :: */[
            x,
            updateAt(index - 1 | 0, f, xs$1)
          ];
  }
}

function insertAt(index, e, xs) {
  if (index < 0) {
    return xs;
  } else if (xs) {
    if (index === 0) {
      return /* :: */[
              e,
              xs
            ];
    } else {
      return /* :: */[
              xs[0],
              insertAt(index - 1 | 0, e, xs[1])
            ];
    }
  } else {
    return /* [] */0;
  }
}

function imapAux(f, i, xs) {
  if (xs) {
    return /* :: */[
            Curry._2(f, i, xs[0]),
            imapAux(f, i + 1 | 0, xs[1])
          ];
  } else {
    return /* [] */0;
  }
}

function imap(f, xs) {
  return imapAux(f, 0, xs);
}

function ifoldrAux(f, index, acc, xs) {
  if (xs) {
    return Curry._3(f, index, xs[0], ifoldrAux(f, index + 1 | 0, acc, xs[1]));
  } else {
    return acc;
  }
}

function ifoldr(f, initial, xs) {
  return ifoldrAux(f, 0, initial, xs);
}

function ifoldlAux(f, _index, _acc, _xs) {
  while(true) {
    var xs = _xs;
    var acc = _acc;
    var index = _index;
    if (!xs) {
      return acc;
    }
    _xs = xs[1];
    _acc = Curry._3(f, acc, index, xs[0]);
    _index = index + 1 | 0;
    continue ;
  };
}

function ifoldl(f, initial, xs) {
  return ifoldlAux(f, 0, initial, xs);
}

function iallAux(f, _index, _xs) {
  while(true) {
    var xs = _xs;
    var index = _index;
    if (!xs) {
      return true;
    }
    if (!Curry._2(f, index, xs[0])) {
      return false;
    }
    _xs = xs[1];
    _index = index + 1 | 0;
    continue ;
  };
}

function iall(f, xs) {
  return iallAux(f, 0, xs);
}

function ianyAux(f, _index, _xs) {
  while(true) {
    var xs = _xs;
    var index = _index;
    if (!xs) {
      return false;
    }
    if (Curry._2(f, index, xs[0])) {
      return true;
    }
    _xs = xs[1];
    _index = index + 1 | 0;
    continue ;
  };
}

function iany(f, xs) {
  return ianyAux(f, 0, xs);
}

function iconcatMapAux(f, index, xs) {
  if (xs) {
    return Pervasives.$at(Curry._2(f, index, xs[0]), iconcatMapAux(f, index + 1 | 0, xs[1]));
  } else {
    return /* [] */0;
  }
}

function iconcatMap(f, xs) {
  return iconcatMapAux(f, 0, xs);
}

function ifilter(pred, xs) {
  return ifoldr((function (i, x, acc) {
                if (Curry._2(pred, i, x)) {
                  return /* :: */[
                          x,
                          acc
                        ];
                } else {
                  return acc;
                }
              }), /* [] */0, xs);
}

function ipartition(pred, xs) {
  return ifoldr((function (i, x) {
                if (Curry._2(pred, i, x)) {
                  return (function (param) {
                      return Ley_Tuple$OptolithClient.Bifunctor.first((function (acc) {
                                    return /* :: */[
                                            x,
                                            acc
                                          ];
                                  }), param);
                    });
                } else {
                  return (function (param) {
                      return Ley_Tuple$OptolithClient.Bifunctor.second((function (acc) {
                                    return /* :: */[
                                            x,
                                            acc
                                          ];
                                  }), param);
                    });
                }
              }), /* tuple */[
              /* [] */0,
              /* [] */0
            ], xs);
}

function ifindAux(pred, _index, _xs) {
  while(true) {
    var xs = _xs;
    var index = _index;
    if (!xs) {
      return ;
    }
    var x = xs[0];
    if (Curry._2(pred, index, x)) {
      return Caml_option.some(x);
    }
    _xs = xs[1];
    _index = index + 1 | 0;
    continue ;
  };
}

function ifind(pred, xs) {
  return ifindAux(pred, 0, xs);
}

function ifindIndexAux(pred, _index, _xs) {
  while(true) {
    var xs = _xs;
    var index = _index;
    if (!xs) {
      return ;
    }
    if (Curry._2(pred, index, xs[0])) {
      return index;
    }
    _xs = xs[1];
    _index = index + 1 | 0;
    continue ;
  };
}

function ifindIndex(pred, xs) {
  return ifindIndexAux(pred, 0, xs);
}

function ifindIndicesAux(pred, _i, _xs) {
  while(true) {
    var xs = _xs;
    var i = _i;
    if (!xs) {
      return /* [] */0;
    }
    var xs$1 = xs[1];
    if (Curry._2(pred, i, xs[0])) {
      return /* :: */[
              i,
              ifindIndicesAux(pred, i + 1 | 0, xs$1)
            ];
    }
    _xs = xs$1;
    _i = i + 1 | 0;
    continue ;
  };
}

function ifindIndices(pred, xs) {
  return ifindIndicesAux(pred, 0, xs);
}

var Index = {
  indexed: indexed,
  deleteAt: deleteAt,
  deleteAtPair: deleteAtPair,
  setAt: setAt,
  modifyAt: modifyAt,
  updateAt: updateAt,
  insertAt: insertAt,
  imapAux: imapAux,
  imap: imap,
  ifoldrAux: ifoldrAux,
  ifoldr: ifoldr,
  ifoldlAux: ifoldlAux,
  ifoldl: ifoldl,
  iallAux: iallAux,
  iall: iall,
  ianyAux: ianyAux,
  iany: iany,
  iconcatMapAux: iconcatMapAux,
  iconcatMap: iconcatMap,
  ifilter: ifilter,
  ipartition: ipartition,
  ifindAux: ifindAux,
  ifind: ifind,
  ifindIndexAux: ifindIndexAux,
  ifindIndex: ifindIndex,
  ifindIndicesAux: ifindIndicesAux,
  ifindIndices: ifindIndices
};

function $less$plus$great(x, xs) {
  return /* :: */[
          x,
          xs
        ];
}

function head(param) {
  if (param) {
    return param[0];
  } else {
    return Pervasives.invalid_arg("head does only work on non-empty lists. If you do not know whether the list is empty or not, use listToMaybe instead.");
  }
}

function last(_param) {
  while(true) {
    var param = _param;
    if (!param) {
      return Pervasives.invalid_arg("last does only work on non-empty lists.");
    }
    var xs = param[1];
    if (!xs) {
      return param[0];
    }
    _param = xs[1];
    continue ;
  };
}

function tail(param) {
  if (param) {
    return param[1];
  } else {
    return Pervasives.invalid_arg("tail does only work on non-empty lists.");
  }
}

function init(param) {
  if (!param) {
    return Pervasives.invalid_arg("init does only work on non-empty lists.");
  }
  var xs = param[1];
  if (xs) {
    return /* :: */[
            param[0],
            init(xs)
          ];
  } else {
    return /* [] */0;
  }
}

function uncons(param) {
  if (param) {
    return /* tuple */[
            param[0],
            param[1]
          ];
  }
  
}

function reverse(xs) {
  return foldl((function (param, param$1) {
                return Ley_Function$OptolithClient.flip($less$plus$great, param, param$1);
              }), /* [] */0, xs);
}

function intersperse(sep, xs) {
  if (!xs) {
    return /* [] */0;
  }
  var xs$1 = xs[1];
  var x = xs[0];
  if (xs$1) {
    return /* :: */[
            x,
            /* :: */[
              sep,
              intersperse(sep, xs$1)
            ]
          ];
  } else {
    return /* :: */[
            x,
            /* [] */0
          ];
  }
}

function intercalate(separator, xs) {
  if (!xs) {
    return "";
  }
  var xs$1 = xs[1];
  var x = xs[0];
  if (xs$1) {
    return intercalate(separator, xs$1) + (separator + x);
  } else {
    return x;
  }
}

function permutationsPick(xs) {
  return imapAux((function (i, x) {
                return /* tuple */[
                        x,
                        deleteAt(i, xs)
                      ];
              }), 0, xs);
}

function permutations(xs) {
  if (xs) {
    if (xs[1]) {
      return $great$great$eq(permutationsPick(xs), (function (param) {
                    var x$prime = param[0];
                    return $less$$great((function (param) {
                                  return /* :: */[
                                          x$prime,
                                          param
                                        ];
                                }), permutations(param[1]));
                  }));
    } else {
      return /* :: */[
              /* :: */[
                xs[0],
                /* [] */0
              ],
              /* [] */0
            ];
    }
  } else {
    return /* [] */0;
  }
}

function scanl(f, initial, xs) {
  return /* :: */[
          initial,
          xs ? scanl(f, Curry._2(f, initial, xs[0]), xs[1]) : /* [] */0
        ];
}

function mapAccumL(f, initial, ls) {
  if (!ls) {
    return /* tuple */[
            initial,
            /* [] */0
          ];
  }
  var match = Curry._2(f, initial, ls[0]);
  var match$1 = mapAccumL(f, match[0], ls[1]);
  return /* tuple */[
          match$1[0],
          /* :: */[
            match[1],
            match$1[1]
          ]
        ];
}

function mapAccumR(f, initial, ls) {
  if (!ls) {
    return /* tuple */[
            initial,
            /* [] */0
          ];
  }
  var match = mapAccumR(f, initial, ls[1]);
  var match$1 = Curry._2(f, match[0], ls[0]);
  return /* tuple */[
          match$1[0],
          /* :: */[
            match$1[1],
            match[1]
          ]
        ];
}

function replicate(len, x) {
  if (len > 0) {
    return /* :: */[
            x,
            replicate(len - 1 | 0, x)
          ];
  } else {
    return /* [] */0;
  }
}

function unfoldr(f, seed) {
  var param = Curry._1(f, seed);
  if (param !== undefined) {
    return /* :: */[
            param[0],
            unfoldr(f, param[1])
          ];
  } else {
    return /* [] */0;
  }
}

function take(n, xs) {
  if (n <= 0 || !xs) {
    return /* [] */0;
  } else {
    return /* :: */[
            xs[0],
            take(n - 1 | 0, xs[1])
          ];
  }
}

function drop(_n, _xs) {
  while(true) {
    var xs = _xs;
    var n = _n;
    if (n <= 0) {
      return xs;
    }
    if (!xs) {
      return /* [] */0;
    }
    _xs = xs[1];
    _n = n - 1 | 0;
    continue ;
  };
}

function splitAt(n, xs) {
  if (n <= 0) {
    return /* tuple */[
            /* [] */0,
            xs
          ];
  }
  if (!xs) {
    return /* tuple */[
            /* [] */0,
            xs
          ];
  }
  var match = splitAt(n - 1 | 0, xs[1]);
  return /* tuple */[
          /* :: */[
            xs[0],
            match[0]
          ],
          match[1]
        ];
}

function isInfixOf(x, y) {
  return x.includes(y);
}

function lookup(k, xs) {
  return Ley_Option$OptolithClient.Functor.$less$amp$great(find((function (param) {
                    return Caml_obj.caml_equal(k, param[0]);
                  }), xs), (function (prim) {
                return prim[1];
              }));
}

function filter(pred, xs) {
  return foldr((function (x) {
                if (Curry._1(pred, x)) {
                  return (function (param) {
                      return /* :: */[
                              x,
                              param
                            ];
                    });
                } else {
                  return Ley_Function$OptolithClient.id;
                }
              }), /* [] */0, xs);
}

function partition(pred, xs) {
  return foldr((function (x) {
                if (Curry._1(pred, x)) {
                  return (function (param) {
                      return Ley_Tuple$OptolithClient.Bifunctor.first((function (param) {
                                    return /* :: */[
                                            x,
                                            param
                                          ];
                                  }), param);
                    });
                } else {
                  return (function (param) {
                      return Ley_Tuple$OptolithClient.Bifunctor.second((function (param) {
                                    return /* :: */[
                                            x,
                                            param
                                          ];
                                  }), param);
                    });
                }
              }), /* tuple */[
              /* [] */0,
              /* [] */0
            ], xs);
}

function elemIndex(e, xs) {
  if (xs) {
    if (Caml_obj.caml_equal(e, xs[0])) {
      return 0;
    } else {
      return Ley_Option$OptolithClient.Functor.$less$$great(Ley_Int$OptolithClient.inc, elemIndex(e, xs[1]));
    }
  }
  
}

function elemIndicesAux(e, _i, _xs) {
  while(true) {
    var xs = _xs;
    var i = _i;
    if (!xs) {
      return /* [] */0;
    }
    var xs$1 = xs[1];
    if (Caml_obj.caml_equal(e, xs[0])) {
      return /* :: */[
              i,
              elemIndicesAux(e, i + 1 | 0, xs$1)
            ];
    }
    _xs = xs$1;
    _i = i + 1 | 0;
    continue ;
  };
}

function elemIndices(e, xs) {
  return elemIndicesAux(e, 0, xs);
}

function findIndex(pred, xs) {
  if (xs) {
    if (Curry._1(pred, xs[0])) {
      return 0;
    } else {
      return Ley_Option$OptolithClient.Functor.$less$$great(Ley_Int$OptolithClient.inc, findIndex(pred, xs[1]));
    }
  }
  
}

function findIndicesAux(pred, _i, _xs) {
  while(true) {
    var xs = _xs;
    var i = _i;
    if (!xs) {
      return /* [] */0;
    }
    var xs$1 = xs[1];
    if (Curry._1(pred, xs[0])) {
      return /* :: */[
              i,
              findIndicesAux(pred, i + 1 | 0, xs$1)
            ];
    }
    _xs = xs$1;
    _i = i + 1 | 0;
    continue ;
  };
}

function findIndices(pred, xs) {
  return findIndicesAux(pred, 0, xs);
}

function zip(xs, ys) {
  if (xs && ys) {
    return /* :: */[
            /* tuple */[
              xs[0],
              ys[0]
            ],
            zip(xs[1], ys[1])
          ];
  } else {
    return /* [] */0;
  }
}

function zipWith(f, xs, ys) {
  if (xs && ys) {
    return /* :: */[
            Curry._2(f, xs[0], ys[0]),
            zipWith(f, xs[1], ys[1])
          ];
  } else {
    return /* [] */0;
  }
}

function lines(x) {
  if (x.length === 0) {
    return /* [] */0;
  } else {
    return Ley_Option$OptolithClient.catOptions($$Array.to_list(x.replace(/\n$/u, "").split(/\n/u)));
  }
}

function nub(xs) {
  return foldr((function (x, acc) {
                if (notElem(x, acc)) {
                  return /* :: */[
                          x,
                          acc
                        ];
                } else {
                  return acc;
                }
              }), /* [] */0, xs);
}

function $$delete(e, _xs) {
  while(true) {
    var xs = _xs;
    if (!xs) {
      return /* [] */0;
    }
    var xs$1 = xs[1];
    if (Caml_obj.caml_equal(e, xs[0])) {
      return xs$1;
    }
    _xs = xs$1;
    continue ;
  };
}

function intersect(xs, ys) {
  return filter((function (param) {
                return Ley_Function$OptolithClient.flip(elem, ys, param);
              }), xs);
}

function sortBy(f) {
  return (function (param) {
      return List.sort((function (a, b) {
                    return Ley_Ord$OptolithClient.fromOrdering(Curry._2(f, a, b));
                  }), param);
    });
}

function maximumBy(f, xs) {
  return foldr1((function (x, acc) {
                var param = Curry._2(f, x, acc);
                if (param >= 2) {
                  return x;
                } else {
                  return acc;
                }
              }), xs);
}

function minimumBy(f, xs) {
  return foldr1((function (x, acc) {
                var param = Curry._2(f, x, acc);
                if (param !== 0) {
                  return acc;
                } else {
                  return x;
                }
              }), xs);
}

function countBy(f, xs) {
  return foldr((function (x) {
                if (Curry._1(f, x)) {
                  return Ley_Int$OptolithClient.inc;
                } else {
                  return Ley_Function$OptolithClient.id;
                }
              }), 0, xs);
}

var lower = $$String.lowercase_ascii;

function trimStart(str) {
  return str.replace(/^\s+/u, "");
}

function trimEnd(str) {
  return str.replace(/\s+$/u, "");
}

var partial_arg = /[.*+?^${}()|[\]\\]/gu;

function escapeRegex(param) {
  return param.replace(partial_arg, "\\$&");
}

function splitOn(del, x) {
  return $$Array.to_list(x.split(del));
}

function notNull(xs) {
  return !(
          xs ? false : true
        );
}

function notNullStr(xs) {
  return 0 < xs.length;
}

function list(def, f, xs) {
  if (xs) {
    return Curry._2(f, xs[0], xs[1]);
  } else {
    return def;
  }
}

function unsnoc(xs) {
  if (!xs) {
    return ;
  }
  var xs$1 = xs[1];
  var x = xs[0];
  if (!xs$1) {
    return /* tuple */[
            /* [] */0,
            x
          ];
  }
  var match = unsnoc(xs$1);
  if (match !== undefined) {
    return /* tuple */[
            /* :: */[
              x,
              match[0]
            ],
            match[1]
          ];
  }
  
}

function snoc(xs, x) {
  if (!xs) {
    return /* :: */[
            x,
            /* [] */0
          ];
  }
  var x$1 = xs[0];
  return /* :: */[
          x$1,
          snoc(xs[1], x$1)
        ];
}

function maximumOn(f, xs) {
  return Ley_Tuple$OptolithClient.fst(foldr((function (x, param) {
                    var max = param[1];
                    var res = Curry._1(f, x);
                    if (res > max) {
                      return /* tuple */[
                              Caml_option.some(x),
                              res
                            ];
                    } else {
                      return /* tuple */[
                              param[0],
                              max
                            ];
                    }
                  }), /* tuple */[
                  undefined,
                  Js_int.min
                ], xs));
}

function minimumOn(f, xs) {
  return Ley_Tuple$OptolithClient.fst(foldr((function (x, param) {
                    var min = param[1];
                    var res = Curry._1(f, x);
                    if (res < min) {
                      return /* tuple */[
                              Caml_option.some(x),
                              res
                            ];
                    } else {
                      return /* tuple */[
                              param[0],
                              min
                            ];
                    }
                  }), /* tuple */[
                  undefined,
                  Js_int.max
                ], xs));
}

function firstJust(pred, _xs) {
  while(true) {
    var xs = _xs;
    if (!xs) {
      return ;
    }
    var res = Curry._1(pred, xs[0]);
    if (res !== undefined) {
      return res;
    }
    _xs = xs[1];
    continue ;
  };
}

function replaceStr(old_subseq, new_subseq, x) {
  return x.replace(new RegExp(Curry._1(escapeRegex, old_subseq), "gu"), new_subseq);
}

function replaceStrRe(old_subseq_rx, new_subseq, x) {
  return x.replace(old_subseq_rx, new_subseq);
}

var Extra = {
  lower: lower,
  trimStart: trimStart,
  trimEnd: trimEnd,
  escapeRegex: escapeRegex,
  splitOn: splitOn,
  notNull: notNull,
  notNullStr: notNullStr,
  list: list,
  unsnoc: unsnoc,
  snoc: snoc,
  maximumOn: maximumOn,
  minimumOn: minimumOn,
  firstJust: firstJust,
  replaceStr: replaceStr,
  replaceStrRe: replaceStrRe
};

function atMay(xs, i) {
  if (i < 0) {
    return ;
  } else {
    return List.nth_opt(xs, i);
  }
}

var Safe = {
  atMay: atMay
};

var cons = $less$plus$great;

var $caret = Pervasives.$at;

var append = Pervasives.$at;

var map = $less$$great;

var $bang$bang = List.nth;

var subscript = List.nth;

var listToArray = $$Array.of_list;

var arrayToList = $$Array.to_list;

export {
  Functor ,
  Applicative ,
  Alternative ,
  Monad ,
  Foldable ,
  Index ,
  $less$plus$great ,
  cons ,
  $caret ,
  append ,
  head ,
  last ,
  tail ,
  init ,
  uncons ,
  map ,
  reverse ,
  intersperse ,
  intercalate ,
  permutations ,
  scanl ,
  mapAccumL ,
  mapAccumR ,
  replicate ,
  unfoldr ,
  take ,
  drop ,
  splitAt ,
  isInfixOf ,
  elem ,
  notElem ,
  lookup ,
  filter ,
  partition ,
  $bang$bang ,
  subscript ,
  elemIndex ,
  elemIndicesAux ,
  elemIndices ,
  findIndex ,
  findIndicesAux ,
  findIndices ,
  zip ,
  zipWith ,
  lines ,
  nub ,
  $$delete ,
  intersect ,
  sortBy ,
  maximumBy ,
  minimumBy ,
  countBy ,
  listToArray ,
  arrayToList ,
  Extra ,
  Safe ,
  
}
/* No side effect */
